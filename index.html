<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nutritional Insights</title>
        <!--
            Nutritional Insights Dashboard (project2ui.html)

            Overview
            - Single-page, client-only dashboard to explore macronutrient insights by diet type.
            - Styling via Tailwind CSS (CDN) and charts via Chart.js v3.x (CDN).
            - Uses static demo data derived from Project1Files/All_Diets.csv for quick iteration.

            Key UI Sections
            - Header: Page title and branding.
            - Cards Grid:
                    • Bar chart: Avg Protein/Carbs/Fat by diet type.
                    • Scatter plot: Protein vs. Carbs for top protein recipes.
                    • Heatmap: Static placeholder showing correlation-like values (for demo only).
                    • Pie chart: Recipe distribution by diet type.
            - Filters: Text search + diet dropdown; updates charts and table with pagination.
            - API Buttons: Simulated “Get Nutritional Insights / Recipes / Clusters” responses.
            - Data Table: Paged table for the currently filtered data set.

            Data Model (demo)
            - dietTypesData: [{ Diet_type: string, Protein: number, Carbs: number, Fat: number, recipes: number }]
            - topProteinRecipes: [{ recipe: string, protein: number, carbs: number }]
            - itemsPerPage (number) controls table pagination size.

            Behavior
            - Filtering triggers updateCharts(filteredData) and re-renders the table + pagination.
            - Charts are responsive; bar/pie datasets are recomputed from filteredData.
            - API functions (getNutritionalInsights / getRecipes / getClusters) currently stub UI
                feedback only. Replace with real network calls when backend is available.

            Hooking up a real API (example sketch)
            - Replace getNutritionalInsights() body with:
                    fetch('/api/nutrition/summary')
                        .then(r => r.json())
                        .then(json => {
                            // Map json to dietTypesData shape, then:
                            filteredData = mapServerData(json)
                            currentPage = 1
                            updateCharts(filteredData)
                            renderTable()
                            showMessage('✓ Nutritional Insights Retrieved', json.meta)
                        })
                        .catch(err => showError('Failed to retrieve insights', err))

            Dependencies & Versions
            - Tailwind CSS: 2.0.0 (CDN). If upgrading to v3, utilities and purge/content config may differ.
            - Chart.js: 3.9.1. If upgrading to v4, note breaking changes to scales/ticks and options.

            Known Limitations / Next Steps
            - Heatmap is static; consider generating from real correlation matrix and rendering via canvas/SVG.
            - Demo metrics (e.g., 7,806 records) are placeholders; sync with backend or CSV pipeline.
            - Consider accessibility improvements (ARIA labels for controls, focus states for buttons).
            - Consider extracting scripts into separate JS module and adding lightweight tests.

            How to use
            - Open this HTML file directly in a modern browser.
            - Search or choose a diet to filter; charts and table will update.
            - Click API buttons to see simulated responses; wire them to real endpoints later.
        -->
    <!-- Tailwind CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.0.0/dist/tailwind.min.css" rel="stylesheet">
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
        }
        main {
            flex: 1 0 auto;
        }
        footer {
            flex-shrink: 0;
        }
    </style>
</head>
<body class="bg-gray-100">

    <header class="bg-blue-600 p-4 text-white">
        <h1 class="text-3xl font-semibold">Nutritional Insights</h1>
    </header>

    <main class="container mx-auto p-6">
        <section class="mb-8">
            <h2 class="text-2xl font-semibold mb-4">Explore Nutritional Insights</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                <div class="bg-white p-4 shadow-lg rounded-lg">
                    <h3 class="font-semibold">Bar Chart</h3>
                    <p class="text-sm text-gray-600">Average macronutrient content by diet type.</p>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="barChart"></canvas>
                    </div>
                </div>

                <div class="bg-white p-4 shadow-lg rounded-lg">
                    <h3 class="font-semibold">Scatter Plot</h3>
                    <p class="text-sm text-gray-600">Nutrient relationships (e.g., protein vs carbs).</p>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="scatterPlot"></canvas>
                    </div>
                </div>

                <div class="bg-white p-4 shadow-lg rounded-lg">
                    <h3 class="font-semibold">Heatmap</h3>
                    <p class="text-sm text-gray-600">Nutrient correlations.</p>
                    <div id="heatmap" class="w-full h-48 flex items-center justify-center">
                        <div class="grid grid-cols-3 gap-1 text-center">
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 1.0);">1.00</div>
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 0.45);">-0.45</div>
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 0.32);">-0.32</div>
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 0.45);">-0.45</div>
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 1.0);">1.00</div>
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 0.78);">0.78</div>
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 0.32);">-0.32</div>
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 0.78);">0.78</div>
                            <div class="w-12 h-12 flex items-center justify-center text-white text-xs font-bold rounded" style="background-color: rgba(59, 130, 246, 1.0);">1.00</div>
                        </div>
                    </div>
                    <div class="flex justify-around mt-2 text-xs">
                        <span>Protein</span>
                        <span>Carbs</span>
                        <span>Fat</span>
                    </div>
                </div>

                <div class="bg-white p-4 shadow-lg rounded-lg">
                    <h3 class="font-semibold">Pie Chart</h3>
                    <p class="text-sm text-gray-600">Recipe distribution by diet type.</p>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="pieChart"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <section class="mb-8">
            <h2 class="text-2xl font-semibold mb-4">Filters and Data Interaction</h2>
            <div class="flex flex-wrap gap-4">
                <input type="text" id="searchInput" placeholder="Search by Diet Type" class="p-2 border rounded w-full sm:w-auto">
                <select id="dietSelect" class="p-2 border rounded w-full sm:w-auto">
                    <option value="all">All Diet Types</option>
                    <option value="vegan">Vegan</option>
                    <option value="keto">Keto</option>
                    <option value="paleo">Paleo</option>
                    <option value="mediterranean">Mediterranean</option>
                    <option value="dash">Dash</option>
                </select>
            </div>
        </section>

        <section class="mb-8">
            <h2 class="text-2xl font-semibold mb-4">API Data Interaction</h2>
            <div class="flex flex-wrap gap-4">
                <button onclick="getNutritionalInsights()" class="bg-blue-600 text-white py-2 px-4 rounded">Get Nutritional Insights</button>
                <button onclick="getRecipes()" class="bg-green-600 text-white py-2 px-4 rounded">Get Recipes</button>
                <button onclick="getClusters()" class="bg-purple-600 text-white py-2 px-4 rounded">Get Clusters</button>
            </div>
            
            <div id="apiResponse" class="mt-4 p-4 bg-green-50 border border-green-200 rounded hidden">
                <h3 class="font-semibold text-green-800 mb-2">API Response</h3>
                <div class="text-sm text-gray-700">
                    <p><strong>Status:</strong> success</p>
                    <p><strong>Message:</strong> Processed nutritional data from Azurite Blob Storage</p>
                    <p><strong>Source File:</strong> All_Diets.csv</p>
                    <p><strong>Records Processed:</strong> 7,806</p>
                    <p><strong>Diet Types Analyzed:</strong> 5</p>
                    <p><strong>Output File:</strong> simulated_nosql/nutrition_results.json</p>
                    <p><strong>Processing Time:</strong> 2.1s</p>
                    <p><strong>Memory Used:</strong> 63MB</p>
                </div>
            </div>
        </section>

        <section>
            <h2 class="text-2xl font-semibold mb-4">Data Table</h2>
            <div class="bg-white p-4 shadow-lg rounded-lg overflow-x-auto">
                <table class="min-w-full table-auto">
                    <thead class="bg-gray-200">
                        <tr>
                            <th class="px-4 py-2 text-left">Diet Type</th>
                            <th class="px-4 py-2 text-left">Protein (g)</th>
                            <th class="px-4 py-2 text-left">Carbs (g)</th>
                            <th class="px-4 py-2 text-left">Fat (g)</th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody">
                    </tbody>
                </table>
            </div>
            <div class="flex justify-center gap-2 mt-4" id="paginationControls">
            </div>
        </section>
    </main>

    <footer class="bg-blue-600 p-4 text-white text-center">
        <p>&copy; 2025 Nutritional Insights. All Rights Reserved.</p>
        <p class="mt-2 font-semibold">Group 7</p>
        <p class="mt-1">Annie . Komalpreet . Rhailyn Jane</p>
    </footer>

    <script>
        // API Configuration
        // Base URL for the Flask backend. If you change the backend host/port,
        // update this constant. All fetch calls below are composed from this.
        const API_BASE_URL = 'http://127.0.0.1:5000/api';

        // Data will be loaded from backend
        // These arrays are populated by loadDataFromBackend() and then
        // used by charts, filters, and the table renderer.
        let dietTypesData = [];
        let topProteinRecipes = [];

        // State variables for filtering and pagination
        let filteredData = [];
        let currentPage = 1;
        const itemsPerPage = 3;

        // Load data from backend on page load
        // Load initial datasets required by the page:
        // 1) nutrition summary by diet (bar + pie charts + table)
        // 2) top-protein recipes (scatter plot)
        /**
         * Load initial datasets required by the dashboard and render charts/table.
         * Fetches nutrition summary and top-protein recipes from the backend API.
         * @returns {Promise<void>}
         */
        async function loadDataFromBackend() {
            try {
                // Fetch nutrition summary
                // Shape (success): { status, total_records, diet_types, data: [...] }
                const summaryResponse = await fetch(`${API_BASE_URL}/nutrition/summary`);
                const summaryData = await summaryResponse.json();
                
                if (summaryData.status === 'success') {
                    // Normalize local state and render charts/table
                    dietTypesData = summaryData.data;
                    filteredData = [...dietTypesData];
                    
                    // Update charts and table
                    updateCharts(filteredData);
                    renderTable();
                }

                // Fetch top protein recipes
                // Shape (success): { status, count, data: [{recipe, protein, carbs}, ...] }
                const proteinResponse = await fetch(`${API_BASE_URL}/recipes/top-protein?limit=5`);
                const proteinData = await proteinResponse.json();
                
                if (proteinData.status === 'success') {
                    topProteinRecipes = proteinData.data;
                    updateScatterPlot();
                }
            } catch (error) {
                console.error('Error loading data from backend:', error);
                showError('Failed to connect to backend API. Please ensure the server is running on port 5000.');
            }
        }

        // Render a prominent error box in the API response area.
        /**
         * Show a prominent error message in the API response panel.
         * @param {string} message - Human-readable error details to display.
         */
        function showError(message) {
            const response = document.getElementById('apiResponse');
            response.classList.remove('hidden');
            response.className = 'mt-4 p-4 bg-red-50 border border-red-200 rounded';
            response.innerHTML = `
                <h3 class="font-semibold text-red-800 mb-2">❌ Error</h3>
                <div class="text-sm text-gray-700">
                    <p>${message}</p>
                </div>
            `;
        }

        // Bar Chart - Average Macronutrients
        // Initializes an empty chart; datasets are populated via updateCharts().
        const barCtx = document.getElementById('barChart').getContext('2d');
        let barChart = new Chart(barCtx, {
            type: 'bar',
            data: {
                labels: dietTypesData.map(d => d.Diet_type),
                datasets: [
                    {
                        label: 'Protein (g)',
                        data: dietTypesData.map(d => d.Protein),
                        backgroundColor: '#3B82F6'
                    },
                    {
                        label: 'Carbs (g)',
                        data: dietTypesData.map(d => d.Carbs),
                        backgroundColor: '#10B981'
                    },
                    {
                        label: 'Fat (g)',
                        data: dietTypesData.map(d => d.Fat),
                        backgroundColor: '#F59E0B'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true } // keep Y-axis starting at 0 for clarity
                }
            }
        });

        // Scatter Plot - Protein vs Carbs
        // Filled later by updateScatterPlot() from topProteinRecipes.
        const scatterCtx = document.getElementById('scatterPlot').getContext('2d');
        let scatterChart = new Chart(scatterCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Top Protein Recipes',
                    data: [],
                    backgroundColor: '#8B5CF6'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: { display: true, text: 'Protein (g)' }
                    },
                    y: {
                        title: { display: true, text: 'Carbs (g)' }
                    }
                }
            }
        });

        // Push points into the scatter dataset and trigger a redraw.
        /**
         * Refresh the scatter plot with current `topProteinRecipes` data.
         * @returns {void}
         */
        function updateScatterPlot() {
            scatterChart.data.datasets[0].data = topProteinRecipes.map(r => ({ x: r.protein, y: r.carbs }));
            scatterChart.update();
        }

        // Pie Chart - Recipe Distribution
        // Labels and counts are derived from the current (filtered) diet types.
        const pieCtx = document.getElementById('pieChart').getContext('2d');
        let pieChart = new Chart(pieCtx, {
            type: 'pie',
            data: {
                labels: dietTypesData.map(d => d.Diet_type),
                datasets: [{
                    data: dietTypesData.map(d => d.recipes),
                    backgroundColor: ['#3B82F6', '#10B981', '#8B5CF6', '#F59E0B', '#EF4444', '#06B6D4']
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false
            }
        });

        // API Interaction Functions
        // These functions call the backend endpoints on-demand and display
        // a summary of the result in the green API response panel.
        /**
         * Fetch and display the nutrition summary in the API response panel.
         * Also shows client-side timing for reference.
         * @returns {Promise<void>}
         */
        async function getNutritionalInsights() {
            const response = document.getElementById('apiResponse');
            response.classList.remove('hidden');
            response.className = 'mt-4 p-4 bg-green-50 border border-green-200 rounded';
            
            try {
                const startTime = performance.now();
                const res = await fetch(`${API_BASE_URL}/nutrition/summary`);
                const data = await res.json();
                const endTime = performance.now();
                const processingTime = ((endTime - startTime) / 1000).toFixed(2);
                
                response.innerHTML = `
                    <h3 class="font-semibold text-green-800 mb-2">✓ Nutritional Insights Retrieved</h3>
                    <div class="text-sm text-gray-700">
                        <p><strong>Status:</strong> ${data.status}</p>
                        <p><strong>Total Records:</strong> ${data.total_records.toLocaleString()}</p>
                        <p><strong>Diet Types:</strong> ${data.diet_types}</p>
                        <p><strong>Source:</strong> All_Diets.csv (via Backend API)</p>
                        <p><strong>Processing Time:</strong> ${processingTime}s</p>
                    </div>
                `;
            } catch (error) {
                showError('Failed to retrieve nutritional insights: ' + error.message);
            }
        }

        /**
         * Fetch and display recipe statistics (optionally filtered by diet type).
         * @returns {Promise<void>}
         */
        async function getRecipes() {
            const response = document.getElementById('apiResponse');
            response.classList.remove('hidden');
            response.className = 'mt-4 p-4 bg-green-50 border border-green-200 rounded';
            
            try {
                const startTime = performance.now();
                const res = await fetch(`${API_BASE_URL}/recipes`);
                const data = await res.json();
                const endTime = performance.now();
                const processingTime = ((endTime - startTime) / 1000).toFixed(2);
                
                response.innerHTML = `
                    <h3 class="font-semibold text-green-800 mb-2">✓ Recipes Retrieved</h3>
                    <div class="text-sm text-gray-700">
                        <p><strong>Status:</strong> ${data.status}</p>
                        <p><strong>Total Recipes:</strong> ${data.statistics.total_recipes.toLocaleString()}</p>
                        <p><strong>Average Protein:</strong> ${data.statistics.avg_protein}g</p>
                        <p><strong>Average Carbs:</strong> ${data.statistics.avg_carbs}g</p>
                        <p><strong>Average Fat:</strong> ${data.statistics.avg_fat}g</p>
                        <p><strong>Processing Time:</strong> ${processingTime}s</p>
                    </div>
                `;
            } catch (error) {
                showError('Failed to retrieve recipes: ' + error.message);
            }
        }

        /**
         * Fetch and display simple macronutrient-based cluster groupings.
         * @returns {Promise<void>}
         */
        async function getClusters() {
            const response = document.getElementById('apiResponse');
            response.classList.remove('hidden');
            response.className = 'mt-4 p-4 bg-green-50 border border-green-200 rounded';
            
            try {
                const startTime = performance.now();
                const res = await fetch(`${API_BASE_URL}/clusters`);
                const data = await res.json();
                const endTime = performance.now();
                const processingTime = ((endTime - startTime) / 1000).toFixed(2);
                
                response.innerHTML = `
                    <h3 class="font-semibold text-green-800 mb-2">✓ Cluster Analysis Complete</h3>
                    <div class="text-sm text-gray-700">
                        <p><strong>Status:</strong> ${data.status}</p>
                        <p><strong>Clusters Identified:</strong> ${data.clusters_identified}</p>
                        <p><strong>High Protein Cluster:</strong> ${data.high_protein_cluster.join(', ')}</p>
                        <p><strong>High Carb Cluster:</strong> ${data.high_carb_cluster.join(', ')}</p>
                        <p><strong>Balanced Cluster:</strong> ${data.balanced_cluster.join(', ')}</p>
                        <p><strong>Processing Time:</strong> ${processingTime}s</p>
                    </div>
                `;
            } catch (error) {
                showError('Failed to retrieve clusters: ' + error.message);
            }
        }

        // Update charts based on filtered data
        // This rebinds labels and dataset values for both the bar and pie charts.
        /**
         * Update the bar and pie charts with a filtered dataset.
         * @param {Array<{Diet_type:string,Protein:number,Carbs:number,Fat:number,recipes:number}>} data
         * @returns {void}
         */
        function updateCharts(data) {
            // Update bar chart
            barChart.data.labels = data.map(d => d.Diet_type);
            barChart.data.datasets[0].data = data.map(d => d.Protein);
            barChart.data.datasets[1].data = data.map(d => d.Carbs);
            barChart.data.datasets[2].data = data.map(d => d.Fat);
            barChart.update();

            // Update pie chart
            pieChart.data.labels = data.map(d => d.Diet_type);
            pieChart.data.datasets[0].data = data.map(d => d.recipes);
            pieChart.update();
        }

        // Filter functionality
        document.getElementById('searchInput').addEventListener('input', filterData);
        document.getElementById('dietSelect').addEventListener('change', filterData);

        // Filter table + charts whenever search input or diet dropdown changes.
        /**
         * Filter `dietTypesData` by search term and selected diet; refresh UI.
         * @returns {void}
         */
        function filterData() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const selectedDiet = document.getElementById('dietSelect').value;
            
            // Filter the data
            filteredData = dietTypesData.filter(item => {
                const matchesSearch = item.Diet_type.toLowerCase().includes(searchTerm);
                const matchesDiet = selectedDiet === 'all' || item.Diet_type.toLowerCase() === selectedDiet;
                return matchesSearch && matchesDiet;
            });

            // Reset to first page when filtering
            currentPage = 1;

            // Update charts and table
            updateCharts(filteredData);
            renderTable();
        }

        // Render table with pagination
        // Slices the filtered data for the current page and builds table rows.
        /**
         * Render the paginated table for the current page of `filteredData`.
         * @returns {void}
         */
        function renderTable() {
            const tableBody = document.getElementById('dataTableBody');
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageData = filteredData.slice(startIndex, endIndex);

            // Clear table
            tableBody.innerHTML = '';

            // Add rows
            pageData.forEach(item => {
                const row = document.createElement('tr');
                row.className = 'border-b hover:bg-gray-50';
                row.innerHTML = `
                    <td class="px-4 py-2">${item.Diet_type}</td>
                    <td class="px-4 py-2">${item.Protein.toFixed(2)}</td>
                    <td class="px-4 py-2">${item.Carbs.toFixed(2)}</td>
                    <td class="px-4 py-2">${item.Fat.toFixed(2)}</td>
                `;
                tableBody.appendChild(row);
            });

            renderPagination();
        }

        // Render pagination controls
        // Generates Previous / page numbers / Next buttons, wired to update the table.
        /**
         * Render pagination controls and wire them to update the current page.
         * @returns {void}
         */
        function renderPagination() {
            const paginationControls = document.getElementById('paginationControls');
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);

            paginationControls.innerHTML = '';

            // Previous button
            const prevButton = document.createElement('button');
            prevButton.textContent = 'Previous';
            prevButton.className = `px-3 py-1 rounded ${currentPage === 1 ? 'bg-gray-200 cursor-not-allowed' : 'bg-gray-300 hover:bg-gray-400'}`;
            prevButton.disabled = currentPage === 1;
            prevButton.onclick = () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderTable();
                }
            };
            paginationControls.appendChild(prevButton);

            // Page numbers
            for (let i = 1; i <= totalPages; i++) {
                const pageButton = document.createElement('button');
                pageButton.textContent = i;
                pageButton.className = `px-3 py-1 rounded ${i === currentPage ? 'bg-blue-600 text-white' : 'bg-gray-300 hover:bg-gray-400'}`;
                pageButton.onclick = () => {
                    currentPage = i;
                    renderTable();
                };
                paginationControls.appendChild(pageButton);
            }

            // Next button
            const nextButton = document.createElement('button');
            nextButton.textContent = 'Next';
            nextButton.className = `px-3 py-1 rounded ${currentPage === totalPages ? 'bg-gray-200 cursor-not-allowed' : 'bg-gray-300 hover:bg-gray-400'}`;
            nextButton.disabled = currentPage === totalPages;
            nextButton.onclick = () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    renderTable();
                }
            };
            paginationControls.appendChild(nextButton);
        }

        // Initialize data and table on page load
        // On DOM ready, fetch initial datasets and render.
        document.addEventListener('DOMContentLoaded', () => {
            loadDataFromBackend();
        });
    </script>

</body>
</html>